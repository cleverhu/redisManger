package RedisConfigModel

var notes map[string]string

func init() {
	notes = make(map[string]string, 0)
	notes["acl-pubsub-default"] = "默认情况下，新用户是使用限制权限创建的。从Redis6.2开始，ACL还提供发布/子通道访问管理。为了确保在升级到Redis 6.2时与版本6.0向后兼容，新用户在默认情况下被授予“allchannels”权限。可以通过acl pubsub default配置指令将默认值设置为resetchannels。"
	notes["aclfile"] = "使用外部ACL文件可以在此文件中代替在此处配置用户一个仅列出用户的独立文件。两种方法不能混合使用：如果您在此处配置用户并同时激活外部ACL文件，服务器将拒绝启动。外部ACL用户文件的格式与在redis.conf中用于描述用户的格式。aclfile /etc/redis/users.acl"
	notes["acllog-max-len"] = "ACL日志跟踪失败的命令和关联的身份验证事件与ACL。 ACL日志可用于对阻止的失败命令进行故障排除通过ACL。 ACL日志存储在内存中。您可以使用以下方法回收内存ACL日志重置。在下面定义ACL日志的最大条目长度。"
	notes["active-defrag-cycle-max"] = "最大程度地整理CPU百分比的碎片达到＃个阈值"
	notes["active-defrag-cycle-min"] = "在CPU百分比上进行最小整理的工作量，在较低时使用达到＃个阈值"
	notes["active-defrag-ignore-bytes"] = "启动主动碎片整理的最小碎片浪费量"
	notes["active-defrag-max-scan-fields"] = "将要处理的set / hash / zset / list字段的最大数量主字典扫描"
	notes["active-defrag-threshold-lower"] = "启动活动碎片整理的最小碎片百分比"
	notes["active-defrag-threshold-upper"] = "我们最大程度地努力下的最大碎片百分比"
	notes["active-expire-effort"] = "Redis通过两种方式回收过期的密钥：在访问这些密钥时发现已过期，并且在后台，也就是所谓的“活动的过期密钥”。密钥空间被缓慢地交互扫描寻找可回收的过期密钥，以便可以释放内存过期的密钥数量，将在短期内不再访问。到期周期的默认工作量将尝试避免超过百分之十的过期密钥仍在内存中，并将尝试避免消耗超过总内存的25％，并增加系统延迟。然而可以增加通常设置为的过期“努力”“ 1”，取更大的值，最大取值“ 10”。在最大值系统将使用更多的CPU，周期更长（从技术上讲，更高的延迟），并且可以容忍更少的已过期密钥仍然存在在系统中。在内存，CPU和延迟之间进行权衡。"
	notes["activedefrag"] = "什么是主动碎片整理？主动（在线）碎片整理允许Redis服务器压缩在内存中的小量分配和释放之间留有空格，因此可以回收内存。碎片是每个分配器都会发生的自然过程（但幸运的是，Jemalloc和某些工作负载更少。通常是一台服务器重新启动是必要的，以减少碎片或至少冲洗删除所有数据并再次创建。但是由于这个功能由Oran Agra针对Redis 4.0实施，此过程可以在运行时发生在服务器运行时以“热”方式。基本上在碎片超过一定水平时（请参阅下面的配置选项），Redis将开始创建新的副本通过利用某些特定的Jemalloc在连续内存区域中的＃个值功能（以了解分配是否引起碎片并将其分配到更好的位置），同时，将释放数据的旧副本。对所有键逐步重复此过程将导致碎片恢复到正常值。重要事项：1.此功能默认情况下处于禁用状态，仅在编译Redis时有效使用我们随附Redis源代码的Jemalloc副本。这是Linux构建的默认设置。2.如果没有碎片，则永远不需要启用此功能个问题。3。一旦遇到碎片，您可以在以下情况启用此功能：需要使用命令“ CONFIG SET activedefrag yes”。配置参数能够微调碎片整理过程。如果您不确定它们是什么意思保持默认值不变的好主意。启用主动碎片整理"
	notes["activerehashing"] = "Redis将在每100毫秒时使用1毫秒的CPU时间来对redis的hash表进行重新hash，可以降低内存的使用。当你的使用场景中，有非常严格的实时性需要，不能够接受Redis时不时的对请求有2毫秒的延迟的话，把这项配置为no。如果没有这么严格的实时性要求，可以设置为yes，以便能够尽可能快的释放内存"
	notes["always-show-logo"] = "是否一直显示日志"
	notes["aof-load-truncated"] = "指Redis在恢复时，是否忽略最后一条可能存在问题的指令。默认值yes，在aof写入时，可能存在指令写错的问题(突然断电部分写入)，此时yes会log并继续；而no会直接恢复失败"
	notes["aof-rewrite-incremental-fsync"] = "当孩子重写AOF文件时，如果启用以下选项每生成32 MB的数据，文件就会进行同步处理。这很有用为了将文件更多地提交到磁盘并避免大的延迟峰值"
	notes["aof-use-rdb-preamble"] = "aof与rdb混合模式"
	notes["aof_rewrite_cpulist"] = "将aof rewrite子进程设置为cpu相关性8、9、10、11"
	notes["appendfilename"] = `仅附加文件的名称（默认值：“ appendonly.aof”）appendfilename "appendonly.aof"`
	notes["appendfsync"] = "同步频率 appendfsync参数的可配置值:always：命令写入aof缓冲区后，每一次写入都需要同步写入磁盘（阻塞，系统调用fsync）结束后返回。显然和Redis高性能背道而驰，不建议配置\neverysec：命令写入aof缓冲区后，在写入系统缓冲区直接返回（系统调用write），然后有专门线程每秒执行写入磁盘（阻塞，系统调用fsync）后返回\nno：命令写入aof缓冲区后，在写入系统缓冲区直接返回（系统调用write）。之后写入磁盘（阻塞，系统调用fsync）的操作由操作系统负责，通常最长30s"
	notes["appendonly"] = "是否打开AOF持久化功能"
	notes["auto-aof-rewrite-min-size"] = "如果文件大小小于此值不会触发AOF，默认64MB"
	notes["auto-aof-rewrite-percentage"] = "Redis记录最近一次AOF操作的文件大小，如果当前AOF文件大小增长超过这个百分比则触发一次重写，默认100"
	notes["bgsave_cpulist"] = "将bgsave子进程设置为cpu亲和力1,10,11"
	notes["bind"] = "如果只想让它在一个或多个网络接口上监听，那你就绑定一个IP或者多个IP，多个ip空格分隔即可。"
	notes["bio_cpulist"] = "将生物线程设置为cpu亲和力1,3"
	notes["client-output-buffer-limit"] = "每个client-output-buffer-limit指令的语法如下：client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>一旦达到硬限制，或者如果达到软限制，并保持达到指定数量秒（连续）。例如，如果硬限制为32 MB，软限制为16兆字节/ 10秒，客户端将立即断开连接。如果输出缓冲区的大小达到32兆字节，但也会如果客户端达到16兆字节并持续克服，则断开连接10秒的限制。默认情况下，普通客户端不受限制，因为它们不接收数据不询问（以推送方式），而是在请求之后，因此仅异步客户端可能会创建一个场景，在该场景中，数据请求速度更快比它能读的多。相反，对于pubsub和副本客户端没有默认限制，因为每个订阅者和副本以推送方式接收数据。可以通过将硬限制或软限制设置为零来禁用它们。client-output-buffer-limit normal 0 0 0 client-output-buffer-limit replica 256mb 64mb 60 client-output-buffer-limit pubsub 32mb 8mb 60"
	notes["client-query-buffer-limit"] = "客户端查询缓冲区累积新命令。它们仅限于固定默认情况下为＃数量，以避免协议失步（对于实例（由于客户端中的错误）会导致未绑定的内存使用情况查询缓冲区。但是，如果您有特殊要求，可以在此处进行配置需求，例如我们巨大的multi / exec请求等等。"
	notes["cluster-allow-reads-when-down"] = "此选项设置为yes时，允许节点在集群处于关闭状态，只要它认为自己拥有插槽即可。这在两种情况下很有用。第一种情况是当应用程序在节点故障或网络分区期间不需要数据的一致性。缓存的一个例子，只要节点有数据应该能够提供服务。第二个用例用于不符合建议的配置三个分片，但要启用集群模式并在以后扩展。一种1或2分片配置中的master中断导致对没有设置此选项的整个群集，设置了该选项后，只会发生写中断。如果没有法定人数的主持人，则插槽所有权不会自动更改。"
	notes["cluster-announce-bus-port"] = "每个命令都向节点指示其地址，客户端端口和集群消息总线端口。然后将信息发布在总线数据包的标题中，以便其他节点将能够正确映射该节点的地址发布信息。如果未使用上述选项，则正常的Redis群集自动检测将代替使用。请注意，重新映射后，总线端口可能不在的固定偏移量客户端端口+ 10000，因此您可以根据需要指定任何端口和总线端口如何重新映射它们。如果未设置总线端口，则固定偏移量为10000将照常使用。集群的节点的汇报bus-port,防止nat"
	notes["cluster-announce-ip"] = "集群的节点的汇报ip,防止nat"
	notes["cluster-announce-port"] = "集群的节点的汇报port,防止nat 示例：cluster-announce-ip 10.1.1.5 cluster-announce-port 6379 cluster-announce-bus-port 6380"
	notes["cluster-enabled"] = "普通Redis实例不能属于Redis集群；只有节点在集群节点可以的情况下启动。为了启动一个Redis实例cluster node使群集支持取消注释以下内容：cluster-enabled yes"
	notes["cluster-migration-barrier"] = "群集副本能够迁移到孤立的主数据库（即主数据库）没有可用的副本。这提高了集群能力抵抗失败，否则孤立的主节点无法进行故障转移如果没有可用的副本则失败。仅当仍然存在至少一个副本时，副本服务器才会迁移到孤立的主服务器给定其旧主副本的其他工作副本的数量。这个号码是“移民壁垒”。迁移障碍为1表示副本仅在其主数据库至少有其他1个工作副本时才会迁移依此类推。它通常反映出每个副本所需的副本数集群中的master。默认为1（仅当主服务器保留至少一个副本）。要禁用迁移，只需将其设置为非常大的值即可。可以设置为0，但仅在调试和危险时有用生产中。"
	notes["cluster-node-timeout"] = "认为集群节点失效状态的时间。如果小于0则启动失败"
	notes["cluster-replica-no-failover"] = "此选项设置为yes时，可防止副本尝试对其进行故障转移在主服务器故障期间的主服务器。但是主控仍然可以执行手动故障转移（如果被迫这样做）。这在不同的情况下很有用，尤其是在n多个的情况数据中心操作，如果不希望的话，我们希望一侧永远不会升级如果发生直流故障。"
	notes["cluster-replica-validity-factor"] = "发生故障的主服务器的副本将避免在其数据出现时启动故障转移看起来太旧了。没有简单的方法可以使副本实际具有精确的度量它的“数据年龄”，因此执行以下两项检查：1）如果有多个副本可以进行故障转移，则它们交换消息为了尝试使副本具有最佳优势复制偏移（已处理来自主服务器的更多数据）。副本将尝试按偏移量获得排名，并应用于开始故障转移的数量与它们的等级成正比的延迟。2）每个副本都计算与它的主人。这可以是最后收到的ping或命令（如果主服务器仍处于“已连接”状态），或者自与主服务器断开连接（如果复制链接当前断开）。如果最后一次交互太旧，副本将不会尝试故障转移。用户可以调整点“ 2”。具体来说，副本将无法执行故障转移（如果自从与主机进行最后一次交互以来）经过的次数大于：（节点超时*集群副本有效性因子）+ repl-ping-replica-period例如，如果节点超时为30秒，并且cluster-replica-validity-factor为10，并假设默认的repl-ping-replica-period为10秒，则副本如果无法与主副本通信，则不会尝试进行故障转移超过310秒。较大的群集副本有效性因子可能允许数据过旧的副本进行故障转移master，但值太小可能会阻止群集执行以下操作：完全选择一个副本。为了获得最大可用性，可以设置cluster-replica-validity-factor的值为0，这意味着副本将始终尝试对master，无论他们上次与master互动的时间如何。（但是，他们将始终尝试按比例分配延迟偏移排名）。零是唯一能够保证所有分区恢复正常的值群集将始终能够继续。"
	notes["cluster-require-full-coverage"] = "默认情况下，Redis群集节点如果检测到它们，则停止接受查询至少是一个未显示的哈希槽（没有可用的节点为其提供服务）。如果集群部分关闭，则采用这种方式（例如，一定范围的哈希槽）不再包含）所有群集最终将变得不可用。再次覆盖所有插槽后，它将自动返回可用状态。但是有时您希望集群的子集正常工作，继续接受对仍然存在的键空间部分的查询覆盖。为此，只需设置cluster-require-full-coverage选项为否。"
	notes["cluster-slave-no-failover"] = "在主节点失效期间,从节点不允许对master失效转移\n取值yes,no"
	notes["cluster-slave-validity-factor"] = "如果从节点和master距离上一次通信超过 (node-timeout * replica-validity-factor) + repl-ping-replica-period时间,则没有资格失效转移为master\n如果小于0则启动失败"
	notes["crash-log-enabled"] = "启用崩溃日志"
	notes["crash-memcheck-enabled"] = "启用崩溃内存检查"
	notes["daemonize"] = "是否在后台执行，yes：后台运行；no：不是后台运行"
	notes["databases"] = "设置数据库的数目。默认的数据库是DB 0 ，\n可以在每个连接上使用select <dbid> 命令选择一个不同的数据库，\ndbid是一个介于0到databases - 1 之间的数值。"
	notes["dbfilename"] = "rdb文件的名字。"
	notes["dir"] = "数据库备份的文件放置的路径。路径跟文件名分开配置是因为Redis备份时，先会将当前数据库的状态写入到一个临时文件。等备份完成时，再把该临时文件替换为上面所指定的文件。而临时文件和上面所配置的备份文件都会放在这个指定的路径当中。默认值为 ./"
	notes["disable-thp"] = "从Linux3.15开始，就可以禁用THP（transparent hugepage）设置对于指定的进程。透明的Hugepage支持是一种使用巨大页面来\n#虚拟内存的支持，支持自动\n页面大小的提升和降级没有hugetlbfs的缺点。\n但是修复THP的写页错误需要更多的时间和延迟\n分叉子进程后可能会发生抖动。\n一般情况下，建议配置为“yes”，redis将尝试禁用\n启动时自动启动。如果你有THP的特定用法，设置这个到“no”。"
	notes["dynamic-hz"] = "可选值为yes和no，分别代表开启动态hz和关闭动态hz。默认值为yes。当动态hz开启时，您设置的hz参数的值，即configured_hz，将作为基线值，而Redis服务中的实际hz值会在基线值的基础上根据已连接到Redis的客户端数量自动调整，连接的客户端越多，实际hz值越高，Redis执行定期任务的频率就越高。"
	notes["gopher-enabled"] = "开启gopher功能，默认是no（不开启），关于gopher，详见：https://github.com/antirez/gopher2redis"
	notes["hash-max-ziplist-entries"] = "指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法"
	notes["hash-max-ziplist-value"] = "hash 中的项大小小于或等于这个值使用ziplist\n超过这个值使用hash"
	notes["hll-sparse-max-bytes"] = "大于这个值,hyperloglog使用稠密结构\n小于等于这个值,使用稀疏结构\n大于16000无意义,建议设置3000"
	notes["hz"] = "hz参数用于指定Redis定期任务的执行频率，这些任务包括关闭超时的客户端连接、主动清除过期key等"
	notes["io-threads"] = "线程数\n\n官方建议：4 核的机器建议设置为 2 或 3 个线程，8 核的建议设置为 6 个线程，线程数一定要小于机器核数，尽量不超过8个。"
	notes["io-threads-do-reads"] = "是否开启了多线程"
	notes["jemalloc-bg-thread"] = "默认情况下，将启用用于清除的Jemalloc后台线程"
	notes["key-load-delay"] = "密钥加载延迟"
	notes["latency-monitor-threshold"] = "为了收集可能导致延时的数据根源,redis延时监控系统在运行时会采样一些操作。通过 LATENCY命令 可以打印一些图样和获取一些报告。这个系统仅仅记录那个执行时间大于或等于通过latency-monitor-threshold配置来指定的。当设置为0时这个监控系统关闭。单位毫秒"
	notes["lazyfree-lazy-eviction"] = "默认no,那么redis是同步释放内存,也就是停止完成其他请求来做释放内存操作,如果遇到key复杂度很大时(0(n))的会增加请求延时\n如果yes,那么则先删除dict中的key,然后把释放内存的任务提交给后台线程做"
	notes["lazyfree-lazy-expire"] = "默认no,那么redis是同步删除过期key,也就是停止完成其他请求来做删除过期key,如果遇到key复杂度很大时(0(n))的会增加请求延时\n如果yes,把删除key的任务提交给后台线程做"
	notes["lazyfree-lazy-server-del"] = "默认no,那么redis是同步删除key,也就是停止完成其他请求来做删除key,如果遇到key复杂度很大时(0(n))的会增加请求延时\n如果yes,那么则先删除dict中的key,然后把删除key的任务提交给后台线程做(如果key很小则暂时不删除,只是减少了引用)"
	notes["lazyfree-lazy-user-del"] = "执行DEL命令时是否基于lazyfree异步删除数据，可选值 yes：默认值，开启。no：不开启。"
	notes["lfu-decay-time"] = "是一个以分钟为单位的数值，可以调整counter的减少速度"
	notes["lfu-log-factor"] = "可以调整计数器counter的增长速度，lfu-log-factor越大，counter增长的越慢。"
	notes["list-compress-depth"] = "不压缩quicklist 距离首尾节点小于等于这个值的ziplist节点\n默认首尾节点不压缩,\n设置为1\nhead->next->...->prev->tail\n不压缩next,prev,以此类推\n0表示都不压缩"
	notes["list-max-ziplist-size"] = "负值表示节点大小\n-5 每个list节点大小不能超过64 Kb\n-4 每个list节点大小不能超过32 Kb\n-3 每个list节点大小不能超过16 Kb\n-2 每个list节点大小不能超过8 Kb\n-1 每个list节点大小不能超过4 Kb\n推荐-1,-2\n正值表示节点数量\n\n满足设置的值,则使用ziplist表示,节约内存\n超过设置的值,则使用普通list"
	notes["logfile"] = "日志文件的位置，当指定为空字符串时，为标准输出，如果redis已守护进程模式运行，那么日志将会输出到 /dev/null 。"
	notes["loglevel"] = "日志级别。可选项有：debug（记录大量日志信息，适用于开发、测试阶段）；verbose（较多日志信息）；notice（适量日志信息，使用于生产环境）；warning（仅有部分重要、关键信息才会被记录）。"
	notes["lua-replicate-commands"] = "lua复制命令"
	notes["lua-time-limit"] = "Lua脚本的最大执行时间（以毫秒为单位）。如果达到最大执行时间，Redis将记录脚本在最长允许时间后仍在执行，并将开始执行回复有错误的查询。当长时间运行的脚本超过最大执行时间时，仅SCRIPT KILL和SHUTDOWN NOSAVE命令可用。 第一个可以是用于停止尚未调用任何写命令的脚本。 第二是在执行写命令的情况下关闭服务器的唯一方法已由脚本发出，但用户不想等待自然终止脚本。将其设置为0或负值以无警告地无限执行。"
	notes["masterauth"] = "如果master设置了requirepass，那么slave要连上master，需要有master的密码才行。masterauth就是用来\n配置master的密码，这样可以在连上master后进行认证。"
	notes["masteruser"] = "管理员用户"
	notes["maxclients"] = "同时最大的连接数,默认10000,如果小于1启动失败"
	notes["maxmemory"] = "最大使用内存,超过则触发内存策略"
	notes["maxmemory-eviction-tenacity"] = "最大内存-驱逐韧性"
	notes["maxmemory-policy"] = "取值范围\n1 volatile-lru 在设置了过期的key中通过lfu算法查找key淘汰\n2 volatile-lfu 在所有key中通过lru算法查找key淘汰\n3 volatile-random 在设置了过期的key中随机查找key淘汰\n4 volatile-ttl 最近要超时的key淘汰\n5 allkeys-lru 所有key通过lru算法查找key淘汰\n6 allkeys-lfu 所有key通过lfu算法查找key淘汰\n7 allkeys-random 所有key随机查找key淘汰\n8 noeviction 不淘汰,对于写操作返回错误"
	notes["maxmemory-samples"] = "lru,lfu会对这个数量的key进行检查,设置过高会消耗cpu,如果小于0则启动失败"
	notes["min-replicas-max-lag"] = "最大从节点的落后时间,不满足min-slaves-to-write个 低于这个时间的从节点,master不在接受写请求\n如果小于0则启动失败"
	notes["min-replicas-to-write"] = "redis提供了可以让master停止写入的方式，如果配置了min-replicas-to-write，健康的slave的个数小于N，mater就禁止写入。master最少得有多少个健康的slave存活才能执行写命令。这个配置虽然不能保证N个slave都一定能接收到master的写操作，但是能避免没有足够健康的slave的时候，master不能写入来避免数据丢失。设置为0是关闭该功能"
	notes["min-slaves-max-lag"] = "延迟小于min-replicas-max-lag秒的slave才认为是健康的slave"
	notes["min-slaves-to-write"] = "最少从节点数,不满足min-slaves-to-write个 低于min-slaves-max-lag/min-replicas-max-lag时间的从节点,master不在接受写请求\n如果小于0则启动失败\n默认0,也就是禁用状态书"
	notes["no-appendfsync-on-rewrite"] = "当AOF fsync策略设置为always或everysec，并且有背景保存过程（后台保存或AOF日志后台重写）为在某些Linux配置中，对磁盘执行大量I / ORedis可能在fsync（）调用中阻塞的时间过长。请注意，没有针对当前，因为即使在其他线程中执行fsync也会阻塞我们的同步write（2）调用。为了减轻此问题，可以使用以下选项可以防止在主进程中调用fsync（）时BGSAVE或BGREWRITEAOF正在进行中。这意味着当另一个孩子正在保存时，Redis的持久性是与“ appendfsync none”相同。实际上，这意味着在最坏的情况下可能会丢失多达30秒的日志记录（使用默认Linux设置）。如果您有延迟问题，请将其设为“是”。否则将其保留为从耐久性的角度来看，“＃”是最安全的选择。"
	notes["notify-keyspace-events"] = "Redis可以将关键空间中发生的事件通知给发布/订阅客户端。此功能记录在http://redis.io/topics/notifications例如，如果启用了键空间事件通知，并且客户端对存储在数据库0中的键“ foo”执行DEL操作，两个条消息将通过发布/订阅发布：PUBLISH __keyspace@0__:foo del PUBLISH __keyevent@0__:del foo 可以在一个集合中选择Redis将通知的事件类数。每个类都由一个字符标识：K个键空间事件，以__keyspace @ <db> __前缀发布。E Keyevent事件，以__keyevent @ <db> __前缀发布。g通用命令（非类型专用），例如DEL，EXPIRE，RENAME，... $字符串命令 l列出命令 s设置命令 h哈希命令 z排序集命令 x过期事件（每次密钥过期时生成的事件）e驱逐事件（驱逐密钥以获取最大内存时生成的事件）t流命令 m键丢失事件（注意：它不包含在“ A”类中） g $ lshzxet的别名，因此“ AKE”字符串表示所有事件（除了按键遗失事件外，由于它们独特的性质）。“ notify-keyspace-events”将由组成的字符串作为参数\n零个或多个字符的数量。空字符串表示通知被禁用。示例：从列表的角度启用列表和一般事件事件名称，使用：notify-keyspace-events Elg示例2：获取订阅频道的过期密钥流名称__keyevent @ 0__：过期使用：notify-keyspace-events Ex默认情况下，所有通知都被禁用，因为大多数用户不需要此功能，该功能会有一些开销。请注意，如果您不指定K或E中的至少一个，不会传送任何事件。notify-keyspace-events \"\""
	notes["oom-score-adj"] = "在Linux上，可以向内核提示OOM杀手级进程内存不足时应先被杀死。启用此功能可使Redis主动控制oom_score_adj值取决于其所有流程。默认分数将尝试先杀死后台子进程，然后个副本在高手面前被杀死。"
	notes["oom-score-adj-values"] = "使用oom-score-adj时，此指令控制使用的特定值用于主，副本和后台子进程。 值范围-1000至1000（越高意味着越有可能被杀死）。非特权进程（不是root，并且没有CAP_SYS_RESOURCE功能）可以自由增加其值，但不能将其降低到其初始值以下个设置。服务器使用相对于oom_score_adj的初始值的值开始。 由于初始值通常为0，因此它们通常会与个绝对值。"
	notes["pidfile"] = "配置pid文件路径。当redis以守护模式启动时。\n如果没有配置pidfile，pidfile默认值是/var/run/redis.pid 。"
	notes["port"] = "接受指定端口上的连接，默认值为6379。\n如果指定了端口0，Redis将不会监听TCP套接字。"
	notes["protected-mode"] = "默认情况下启用保护模式。 只有在以下情况下才应禁用它 您确定要让其他主机的客户端连接到Redis即使未配置身份验证，也没有特定的接口集使用“ bind”指令显式列出。"
	notes["proto-max-bulk-len"] = "在Redis协议中，批量请求即表示单个请求的元素个字符串，通常限制为512mb。但是，您可以更改此限制 在这里，但必须大于等于1mb"
	notes["rdb-del-sync-files"] = "rdb文件是否删除同步锁"
	notes["rdb-key-save-delay"] = "rdb密钥保存延迟时间"
	notes["rdb-save-incremental-fsync"] = "每次批量写入磁盘的数据量控制参数，默认为32M。避免单次刷盘数据过多造成硬盘阻塞。"
	notes["rdbchecksum"] = "是否CRC64校验rdb文件，会有一定的性能损失（大概10%）"
	notes["rdbcompression"] = "是否在dump .rdb数据库的时候压缩字符串，默认设置为yes。\n如果你想节约一些cpu资源的话，可以把它设置为no，这样的话数据集就可能会比较大。"
	notes["repl-backlog-size"] = "复制缓冲区大小，这是一个环形复制缓冲区，用来保存最新复制的命令。这样在slave离线的时候，不需要完\n全复制master的数据，如果可以执行部分同步，只需要把缓冲区的部分数据复制给slave，就能恢复正常复制状\n态。缓冲区的大小越大，slave离线的时间可以更长，复制缓冲区只有在有slave连接的时候才分配内存。没有\nslave的一段时间，内存会被释放出来，默认1m"
	notes["repl-backlog-ttl"] = "master没有slave一段时间会释放复制缓冲区的内存，repl-backlog-ttl用来设置该时间长度。单位为秒。"
	notes["repl-disable-tcp-nodelay"] = "是否禁止复制tcp链接的tcp nodelay参数，可传递yes或者no。默认是no，即使用tcp nodelay。如果\nmaster设置了yes来禁止tcp nodelay设置，在把数据复制给slave的时候，会减少包的数量和更小的网络带\n宽。但是这也可能带来数据的延迟。默认我们推荐更小的延迟，但是在数据量传输很大的场景下，建议选择yes"
	notes["repl-diskless-load"] = "警告：RDB无盘加载是实验性的。由于在此设置中，副本不会立即将RDB存储在磁盘上，这可能会导致数据丢失故障转移。 RDB无盘负载+ Redis模块不处理I / O读取也可能导致Redis在初始同步期间发生I / O错误时中止舞台与高手。仅在执行自己的操作时使用。\n复制副本可以直接从复制链接加载从复制链接读取的RDB套接字，或将RDB存储到文件中，并在文件完全读取后读取从主人那里收到的。在许多情况下，磁盘的速度比网络慢，并且存储和加载速度RDB文件可能会增加复制时间（甚至会增加主数据库的复制时间在写内存和从缓冲区中复制）。但是，直接从套接字解析RDB文件可能意味着我们拥有在完整的rdb被清除之前刷新当前数据库的内容收到。因此，我们有以下选择：“disabled”-不要使用无盘负载（首先将rdb文件存储到磁盘“ on-empty-db”-仅在完全安全时才使用无盘加载“swapdb”-解析时在RAM中保留当前数据库内容的副本直接从套接字获取数据。请注意，这需要足够的内存，如果没有足够的内存，则可能会杀死OOM。"
	notes["repl-diskless-sync"] = "是否使用socket方式复制数据。目前redis复制提供两种方式，disk和socket。如果新的slave连上来或者\n重连的slave无法部分同步，就会执行全量同步，master会生成rdb文件。有2种方式：disk方式是master创建\n一个新的进程把rdb文件保存到磁盘，再把磁盘上的rdb文件传递给slave。socket是master创建一个新的进\n程，直接把rdb文件以socket的方式发给slave。disk方式的时候，当一个rdb保存的过程中，多个slave都能\n共享这个rdb文件。socket的方式就的一个个slave顺序复制。在磁盘速度缓慢，网速快的情况下推荐用socket方式。"
	notes["repl-diskless-sync-delay"] = "diskless复制的延迟时间，防止设置为0。一旦复制开始，节点不会再接收新slave的复制请求直到下一个rdb传输。\n所以最好等待一段时间，等更多的slave连上来"
	notes["repl-ping-replica-period"] = "副本以预定义的间隔将PING发送到服务器。有可能使用repl_ping_replica_period选项更改此间隔。默认值值为10秒。"
	notes["repl-ping-slave-period"] = "slave根据指定的时间间隔向服务器发送ping请求。时间间隔可以通过 repl_ping_slave_period 来设置，默认10秒。"
	notes["repl-timeout"] = "设置主从复制过期时间\n这个值一定要比 repl-ping-slave-period 大"
	notes["replica-announce-ip"] = "从节点上报给master的自己ip,防止nat问题"
	notes["replica-announce-port"] = "从节点上报给master的自己port,防止nat问题"
	notes["replica-ignore-maxmemory"] = "从Redis 5开始，默认情况下副本将忽略其maxmemory设置（除非在故障转移后或手动提升为主节点）。它的意思是退出密钥将仅由主机处理，发送DEL命令作为副本在主控端退出到副本。此行为可确保母版和副本保持一致，并且通常您想要的内容，但是如果副本是可写的，或者您想要副本具有不同的内存设置，并且您确定执行了所有写操作到副本是幂等的，则可以更改此默认值（但请确保了解您在做什么。请注意，由于默认情况下该副本不会退出，因此它可能最终会使用更多副本内存比通过maxmemory设置的内存多（某些缓冲区可能在副本上更大，否则数据结构有时可能会占用更多内存等）。因此，请确保您监视副本并确保它们具有足够的内存，永远不会在内存不足之前达到真正的内存不足状态master达到配置的maxmemory设置。"
	notes["replica-lazy-flush"] = "默认no,那么redis是同步清空数据库,也就是停止完成其他请求来做清空数据库,如果遇到数据库很大会增加请求延时\n如果yes,那么则新建dict等数据结构,然后把清空数据库提交给后台线程做"
	notes["replica-priority"] = "当master不可用，Sentinel会根据slave的优先级选举一个master。最低的优先级的slave，当选master。\n而配置成0，永远不会被选举\n"
	notes["replica-read-only"] = "作为从服务器，默认情况下是只读的（yes），可以修改成NO，用于写（不建议）"
	notes["replica-serve-stale-data"] = "默认yes\n当从节点和主节点的连接断开或者复制正在进行中\n设置yes,那么继续提供服务\n设置no,那么返回sync with master in progress"
	notes["requirepass"] = "requirepass配置可以让用户使用AUTH命令来认证密码，才能使用其他命令。这让redis可以使用在不受信任的\n网络中。为了保持向后的兼容性，可以注释该命令，因为大部分用户也不需要认证。使用requirepass的时候需要\n注意，因为redis太快了，每秒可以认证15w次密码，简单的密码很容易被攻破，所以最好使用一个更复杂的密码"
	notes["sanitize-dump-payload"] = "清理转储负载\n\n"
	notes["save"] = "保存数据到磁盘。格式是：save <seconds> <changes> ，\n含义是在 seconds 秒之后至少有 changes个keys 发生改变则保存一次。"
	notes["server_cpulist"] = "服务器CPU列表"
	notes["set-max-intset-entries"] = "set数据类型内部数据如果全部是数值型，且包含多少节点以下会采用紧凑格式存储"
	notes["slave-announce-ip"] = "从节点上报给master的自己ip,防止nat问题"
	notes["slave-announce-port"] = "从节点上报给master的自己port,防止nat问题"
	notes["slave-ignore-maxmemory"] = "从节点是否忽略maxmemory配置,默认yes"
	notes["slave-lazy-flush"] = "默认no,那么redis是同步清空数据库,也就是停止完成其他请求来做清空数据库,如果遇到数据库很大会增加请求延时\n如果yes,那么则新建dict等数据结构,然后把清空数据库提交给后台线程做"
	notes["slave-priority"] = "副本优先级是Redis在INFO中发布的整数输出。 Redis Sentinel使用它来选择要升级的副本如果主服务器不再正常工作，则进入主服务器。优先级低的副本更适合升级，因此例如，如果有三个副本的优先级分别为10、100、25 Sentinel将选择优先级为10的优先级最低的那个。但是，特殊优先级0表示副本无法执行为主角色，因此优先级为0的副本永远不会被Redis前哨升级。默认情况下，优先级为100。"
	notes["slave-read-only"] = "是否允许slave服务器节点只提供读服务"
	notes["slave-serve-stale-data"] = "当slave服务器和master服务器失去连接后，或者当数据正在复制传输的时候，如果此参数值设置“yes”，slave服务器可以继续接受客户端的请求，否则，会返回"
	notes["slaveof"] = "设置该数据库为其他数据库的从数据库\nslaveof <masterip> <masterport> 当本机为从服务时，设置主服务的IP及端口"
	notes["slowlog-log-slower-than"] = "执行命令大于这个值计入慢日志。如果设置为0,则所有命令全部记录慢日志。单位毫秒"
	notes["slowlog-max-len"] = "对日志长度没有限制，只是要注意它会消耗内存\n可以通过 SLOWLOG RESET\n回收被慢日志消耗的内存"
	notes["stop-writes-on-bgsave-error"] = "yes  默认情况下，如果 redis 最后一次的后台保存失败，redis 将停止接受写操作，\n这样以一种强硬的方式让用户知道数据不能正确的持久化到磁盘， 否则就会没人注意到灾难的发生。\n如果后台保存进程重新启动工作了，redis 也将自动的允许写操作。\n然而你要是安装了靠谱的监控，你可能不希望 redis 这样做，那你就改成 no 好了。"
	notes["stream-node-max-bytes"] = "stream 的最大内存开销字节数"
	notes["stream-node-max-entries"] = "stream 的最大项数量"
	notes["supervised"] = "默认no\nsupervised no - 没有监督互动\nsupervised upstart - 通过将Redis置于SIGSTOP模式来启动信号\nsupervised systemd - signal systemd将READY = 1写入$ NOTIFY_SOCKET\nsupervised auto - 检测upstart或systemd方法基于 UPSTART_JOB或NOTIFY_SOCKET环境变量"
	notes["syslog-enabled"] = "是否把日志记录到系统日志。"
	notes["syslog-facility"] = "syslog的facility,取值范围,user,local0-local7"
	notes["syslog-ident"] = "设置系统日志的id     如  syslog-ident redis"
	notes["tcp-backlog"] = "tcp监听队列长度,如果大于/proc/sys/net/core/somaxconn,会取/proc/sys/net/core/somaxconn的值,所以调高此值的时候应该关注/proc/sys/net/ipv4/tcp_max_syn_backlog和/proc/sys/net/core/somaxconn的值\n如果小于0启动失败"
	notes["tcp-keepalive"] = "官方给出的建议值是300S  建议设置成60"
	notes["timeout"] = "客户端和Redis服务端的连接超时时间，默认是0，表示永不超时。"
	notes["tls-auth-clients"] = "tls身份验证客户端"
	notes["tls-ca-cert-dir"] = "tls-ca证书目录"
	notes["tls-ca-cert-file"] = "tls-ca证书文件"
	notes["tls-cert-file"] = "tls证书文件"
	notes["tls-ciphers"] = "tls-密码"
	notes["tls-ciphersuites"] = "配置允许的TLSv1.3密码套件。有关更多信息，请参见ciphers（1ssl）联机帮助页。\n有关此字符串的语法的信息，尤其是针对TLSv1.3的语法\n密码套件。\ntls-ciphersuites TLS_CHACHA20_POLY1305_SHA256"
	notes["tls-client-cert-file"] = "tls客户端证书文件"
	notes["tls-client-key-file"] = "tls客户端密钥文件"
	notes["tls-cluster"] = "默认情况下，Redis群集总线使用纯TCP连接启用。用于总线协议的TLS，请使用以下指令：tls-cluster yes"
	notes["tls-dh-params-file"] = "配置DH参数文件，启用Diffie-Hellman（DH）密钥交换。\ntls-dh-params-file redis.dh"
	notes["tls-key-file"] = "配置X.509证书和私钥以用于认证\n＃服务器连接到连接的客户端，主服务器或集群对等服务器。这些文件应该是\n＃PEM格式化。\n＃\n＃tls-cert-file redis.crt\n＃tls-key-file redis.ke"
	notes["tls-port"] = "默认情况下，禁用TLS / SSL。要启用它，请使用“tls-port”配置\n指令可用于定义TLS侦听端口。要在TLS上启用TLS\n默认端口，使用：# port 0\n tls-port 6379"
	notes["tls-prefer-server-ciphers"] = "tls首选服务器密码"
	notes["tls-protocols"] = "明确指定要支持的TLS版本。允许的值不区分大小写\n＃并包含“ TLSv1”，“ TLSv1.1”，“ TLSv1.2”，“ TLSv1.3”（OpenSSL> = 1.1.1）或\n＃任何组合。要仅启用TLSv1.2和TLSv1.3，请使用：tls-protocols \"TLSv1.2 TLSv1.3\""
	notes["tls-replication"] = "默认情况下，Redis副本不会尝试建立TLS连接与它的主人。\n＃使用以下指令在复制链接上启用TLS。tls-replication yes"
	notes["tls-session-cache-size"] = "更改默认的TLS会话缓存数。零值设置缓存为无限大小。默认大小为20480。"
	notes["tls-session-cache-timeout"] = "更改缓存的TLS会话的默认超时时间。默认超时为300秒。"
	notes["tls-session-caching"] = "默认情况下，启用了TLS会话缓存，以便更快，更便宜支持它的客户端重新连接。使用以下指令禁用缓存。tls-session-caching no"
	notes["tracking-table-max-keys"] = "跟踪表最大键数"
	notes["unixsocket"] = "Unix套接字。指定用于侦听的Unix套接字的路径传入连接。没有默认设置，因此Redis不会收听如果未指定，则在UNIX套接字上。unixsocket /tmp/redis.sock"
	notes["unixsocketperm"] = "Unix套接字。指定用于侦听的Unix套接字的路径传入连接。没有默认设置，因此Redis不会收听如果未指定，则在UNIX套接字上。unixsocketperm 700"
	notes["use-exit-on-panic"] = "当发生panic的时候退出"
	notes["watchdog-period"] = "　CONFIG SET watchdog-period 500 通过CONFIG SET命令设置watchdog-period参数，其值单位为毫秒，在上例中，运行时间超过500毫秒的操作将会被记录下来。 　　注意：这个参数只能通过CONFIG SET来设置，在配置文件里是无法设置的，因为在默认情况下，是绝不推荐开启它的。对性能和稳定性都有影响。当你诊断完成后，可以再通过上面的命令，将延迟时间设置为0来关闭watchdog的功能。"
	notes["zset-max-ziplist-entries"] = "zsort数据类型多少节点以下会采用去指针的紧凑存储格式。"
	notes["zset-max-ziplist-value"] = "zsort数据类型节点值大小小于多少字节会采用紧凑存储格式。"

	notes["list-max-ziplist-entries"] = "list数据类型多少节点以下会采用去指针的紧凑存储格式。"
	notes["list-max-ziplist-value"] = "list数据类型节点值大小小于多少字节会采用紧凑存储格式。"

	notes["cluster-config-file"] = "每个群集节点都有一个群集配置文件。该文件不是旨在手动编辑。它由Redis节点创建和更新。每个Redis群集节点都需要一个不同的群集配置文件。确保在同一系统上运行的实例没有重叠的集群配置文件名。"
	notes["slave-priority/replica-priority"] = "当master不在工作后,从节点提升为master的优先级,0则不会提升为master。越小优先级越高"
	notes["slave-announce-ip/replica-announce-ip"] = "从节点上报给master的自己ip,防止nat问题"
	notes["slave-announce-port/replica-announce-port"] = "从节点上报给master的自己port,防止nat问题"
	notes["sentinel monitor"] = "格式sentinel monitor <master-name> <ip> <redis-port> <quorum>\n如sentinel monitor mymaster 127.0.0.1 6379 2\n告知sentinel监控这个ip和redis-port端口的redis,当至少达到quorum数量的sentinel同意才认为他客观离线(O_DOWN)"
}

type UpdateRedisRequest struct {
	Key      string `json:"key"`
	Value    string `json:"value"`
	Note     string `json:"note"`
	EditFile bool   `json:"file"`
}

func NewUpdateRedisRequest() *UpdateRedisRequest {
	return &UpdateRedisRequest{}
}

type Config struct {
	Key   string `json:"key"`
	Value string `json:"value"`
	Note  string `json:"note"`
}

func NewConfig(key string, value string) *Config {
	note := notes[key]
	//f, err := os.OpenFile("files.txt", os.O_WRONLY|os.O_APPEND|os.O_CREATE, os.ModePerm)
	//fmt.Println(err)
	//f.WriteString(`	notes["` + key + `"]=""` + "\n")
	//f.Close()
	return &Config{Key: key, Value: value, Note: note}
}
